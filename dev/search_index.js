var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This section provides detailed documentation for all public types and functions in SeededAlignment.jl.","category":"page"},{"location":"api/#Core-Types","page":"API Reference","title":"Core Types","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"These types define the fundamental structures used in the alignment algorithms:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Move\nMoveSet\nScoreScheme\nLongDNA{4}","category":"page"},{"location":"api/#Alignment-Functions","page":"API Reference","title":"Alignment Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"These functions perform the actual sequence alignment operations:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"seed_chain_align\nmsa_codon_align\nclean_alignment_readingframe\nnw_align","category":"page"},{"location":"api/#Utilities","page":"API Reference","title":"Utilities","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Helper functions for working with alignment data:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"read_fasta\nwrite_fasta","category":"page"},{"location":"api/#Standard-Parameters","page":"API Reference","title":"Standard Parameters","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Pre-configured settings for common alignment scenarios:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"std_codon_scoring\nstd_codon_moveset\npairwise_noisy_moveset","category":"page"},{"location":"api/#Function-Index","page":"API Reference","title":"Function Index","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"A complete alphabetical listing of all documented functions.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/#SeededAlignment.Move","page":"API Reference","title":"SeededAlignment.Move","text":"Move\n\nRepresents a single allowed alignment step between two sequences in the alignment matrix.\n\nFields\n\nstep::Int: How many aligned units (nucleotides) this move advances by.\nscore::Float64: Cost or score associated with performing this move.\n\nReference to the top sequence (horizontal axis)\n\nhorizontal_stride::Int: How far this move advances along the top (reference) sequence.\nhorizontal_phase::Int: Frame offset in the top sequence; helps track codon boundaries.\n\nReference to the bottom sequence (vertical axis)\n\nvertical_stride::Int: How far this move advances along the bottom (query) sequence.\nvertical_phase::Int: Frame offset in the bottom sequence.\nextensionAble::Bool: Whether this move can be extended (e.g., for affine gap penalties).\n\nDescription\n\nMoves define basic operations used in dynamic programming alignment: matches, mismatches, and gaps. Moves can preserve codon reading frames by keeping strides in multiples of 3 and matching phase positions.\n\nTwo helper constructors are provided:\n\nMove(step, score, stride, phase, extensionAble) assumes reference (vertical) stride and phase\nMove(step, score, extensionAble) for simple moves with unit stride and zero phase.\n\n\n\n\n\n","category":"type"},{"location":"api/#SeededAlignment.MoveSet","page":"API Reference","title":"SeededAlignment.MoveSet","text":"MoveSet\n\nDefines the full set of allowed alignment moves used during pairwise or multiple sequence alignment.\n\nFields\n\nmatch_moves::Vector{Move}: Moves that represent matches or substitutions between nucleotides. \nhor_moves::Vector{Move}: Moves that introduce gaps in the reference (horizontal) sequence.\nvert_moves::Vector{Move}: Moves that introduce gaps in the query (vertical) sequence.\n\nDescription\n\nA MoveSet groups the allowable Moves into categories used during dynamic programming alignment. Each type controls how the algorithm can transition between states, including nucleotide-level match and gap moves with customizable reading frame behavior.\n\nUsed by alignment algorithms such as seed_chain_align and  msa_codon_align to control the scoring and allowed operations during alignment.\n\n\n\n\n\n","category":"type"},{"location":"api/#SeededAlignment.ScoreScheme","page":"API Reference","title":"SeededAlignment.ScoreScheme","text":"ScoreScheme(; match_score=0.0, mismatch_score=0.5,extension_score=0.1,edge_ext_begin=true,edge_ext_end=true,kmerlength=21)\n\nA struct for storing scoring parameters used for sequence alignment. Uses a keyword constructor. \n\nFields\n\nmatch_score::Float64: Score (typically ≤ 0) awarded for matching nucleotide. Lower is better.\nmismatch_score::Float64: Penalty for nucleotide mismatches. Higher values penalize substitutions more strongly.\nextension_score::Float64: Cost to extend a gap (indel). Affects how gaps are penalized during alignment.\nedge_ext_begin::Bool: If true, allows gaps to be extended at the beginning of sequences.\nedge_ext_end::Bool: If true, allows gaps to be extended at the end of sequences.\nkmerlength::Int64: Length of k-mers used for seeding alignments (if applicable). Ignored if no seeding is used.\n\nDescription\n\nScoreScheme defines how matches, mismatches, and gaps are scored during nucleotide-level sequence alignment. \n\nThis struct is typically passed to functions like seed_chain_align or msa_codon_align.\n\nexample\n\nscore_params = ScoreScheme(extension_score = 0.3, mismatch_score = 0.7) # (everything else will be keept at default values)\n\n\n\n\n\n","category":"type"},{"location":"api/#SeededAlignment.clean_alignment_readingframe-Tuple{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}","page":"API Reference","title":"SeededAlignment.clean_alignment_readingframe","text":"clean_alignment_readingframe(aligned_ref::LongDNA{4},aligned_seq::LongDNA{4})\n\nTakes a pairwise alignment of a reference (with known reading frame) and a sequence, and removes single indels which\ndon't respect the reference's reading frame. To clean a full codon alignment you need multiple pairwise alignments and can clean up \nsingle indels by broadcasting with \".\" \n\n# NOTE We assume the readingFrame is 0 mod 3 with sequences 0 indexed\n\n\n\n\n\n","category":"method"},{"location":"api/#SeededAlignment.msa_codon_align","page":"API Reference","title":"SeededAlignment.msa_codon_align","text":"msa_codon_align(ref::LongDNA{4}, seqs::Vector{LongDNA{4}}, moveset::MoveSet, score_params::ScoreScheme)\n\nProduces a fast codon aligment with consistent readingFrame. \n\nArguments\n\nref::LongDNA{4}: The reference DNA sequence, assumed to have an readingFrame which starts at its first nucleotide.\nseqs::Vector{LongDNA{4}}: A vector of DNA sequences to align against the reference.\nmoveset::MoveSet: Defines the allowable alignment operations (e.g. match nucleotide, single indel, readingFrame respecting triple indel). Assumes moveset is choosen so some moves respect the readingFrame.\nscore_params::ScoreScheme: Scoring parameters for codon-aware alignment, including match/mismatch and gap penalties.\n\nReturns\n\nVector{LongDNA{4}}: A vector of aligned sequences (including the reference), with codon-aware gaps that preserve reading frame consistency.\n\nDescription\n\nProduces a fast multiple codon alignment based on a reference with known readingFrame, a moveset and a scoreScheme.  This is done by computing a pairwise alignment with respect to the reference for each sequence and then cleaning up single indel noise.\n\nExample\n\nref = LongDNA{4}(\"ATGACGTGA\")  # Reference with known reading frame\nseqs = [LongDNA{4}(\"ATGTCGTGA\"), LongDNA{4}(\"ATGACGAGA\")]\nmoveset = std_codon_moveset()\nscore_params = std_codon_scoring()\n\nalignment = msa_codon_align(ref, seqs, moveset, score_params)\n\nNOTE: The sequences (ungapped) might not be preserved by the alignment by the cleanup step. Some nucleotides might be inserted or removed.  \n\n\n\n\n\n","category":"function"},{"location":"api/#SeededAlignment.nw_align-Tuple{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, MoveSet, ScoreScheme}","page":"API Reference","title":"SeededAlignment.nw_align","text":"nw_align(A::LongDNA{4},B::LongDNA{4},moveset::MoveSet,scoreScheme::ScoreScheme)\n\nTakes two ungapped LongDNA{4} sequences and computes an optimal pairwise alignment \nwith respect to the moveset and the scoreScheme.\n\n\n\n\n\n","category":"method"},{"location":"api/#SeededAlignment.pairwise_noisy_moveset-Tuple{}","page":"API Reference","title":"SeededAlignment.pairwise_noisy_moveset","text":"pairwise_noisy_moveset()\n\n\n\n\n\n","category":"method"},{"location":"api/#SeededAlignment.read_fasta-Tuple{String}","page":"API Reference","title":"SeededAlignment.read_fasta","text":"read_fasta(filepath::String)\n\nReads in a fasta file and returns a tuple of (seqnames, seqs).\n\n\n\n\n\n","category":"method"},{"location":"api/#SeededAlignment.seed_chain_align-Tuple{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, MoveSet, ScoreScheme}","page":"API Reference","title":"SeededAlignment.seed_chain_align","text":"seed_chain_align(A::LongDNA{4}, B::LongDNA{4}, moveset::MoveSet, scoreScheme::ScoreScheme)\n\nPerform pairwise alignment between two DNA sequences using a seeding strategy.\n\nArguments\n\nA::LongDNA{4}: The first DNA sequence to align.\nB::LongDNA{4}: The second DNA sequence to align.\nmoveset::MoveSet: Defines allowed alignment moves (e.g., match, mismatch, gap).\nscoreScheme::ScoreScheme: Scoring scheme for e.g. matches, mismatches, and gaps.\n\nReturns\n\nVector{LongDNA{4}}: A vector the two aligned sequences.\n\nDescription\n\nThis function performs a fast (sub-quadratic) pairwise alignment using seeding and chaining. It identifies high-scoring seed matches between A and B, chains them to build a candidate alignment skeleton, and fills gaps between seeds using dynamic programming guided by moveset and scoreScheme.\n\nExample\n\nA = LongDNA{4}(\"ACGTACGT\")\nB = LongDNA{4}(\"ACGTTGCA\")\nmoveset = std_codon_moveset()\nscoreScheme = std_codon_scoring()\n\nalignment = seed_chain_align(A, B, moveset, scoreScheme)\n\n\n\n\n\n","category":"method"},{"location":"api/#SeededAlignment.std_codon_moveset-Tuple{}","page":"API Reference","title":"SeededAlignment.std_codon_moveset","text":"std_codon_moveset()\n\nReturn a standard codon-aware MoveSet for sequence alignment.\n\nReturns\n\nMoveSet: Contains codon-aware match and gap moves.\n\nMoves\n\nMatch: Move(1, 0.0)\nHorizontal (gaps in reference sequence):\nMove(1, 2.0, 1, 0, 1, 0, false)\nMove(3, 2.0, 1, 0, 3, 0, true)\nVertical (gaps in query sequence):\nMove(1, 2.0, 1, 0, 1, 0, false)\nMove(3, 2.0, 1, 0, 3, 0, true)\n\nUse this as a default MoveSet for codon-preserving alignments.\n\n\n\n\n\n","category":"method"},{"location":"api/#SeededAlignment.std_codon_scoring-Tuple{}","page":"API Reference","title":"SeededAlignment.std_codon_scoring","text":"std_codon_scoring()\n\nReturn a standard codon-aware ScoreScheme for alignment.\n\nReturns\n\nScoreScheme: Default scoring parameters for codon alignment.\n\nParameters\n\nMatch score: 0.0\nMismatch score: 0.3\nGap extension score: 0.1\nAllow extension at sequence ends: true (both ends)\nK-mer length for seeding: 21\n\nUse this as a default ScoreScheme for codon-preserving alignments.\n\n\n\n\n\n","category":"method"},{"location":"api/#SeededAlignment.write_fasta-Tuple{String, Vector{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}}","page":"API Reference","title":"SeededAlignment.write_fasta","text":"write_fasta(filepath::String, sequences::Vector{LongDNA{4}}; seq_names = nothing)\n\nWrites a fasta file from a vector of sequences, with optional seq_names.\n\n\n\n\n\n","category":"method"},{"location":"#SeededAlignment","page":"Home","title":"SeededAlignment","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SeededAlignment.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SeededAlignment.jl is a flexible high-performance Julia package for aligning DNA sequences. In particular, it can be used to create alignments that preserves reading frame in coding regions. The package provides tools for:","category":"page"},{"location":"","page":"Home","title":"Home","text":"High-performance pairwise alignments using k-mer seeds and chaining\nProducing reading frame preserved multiple sequence alignments\nCustomizable alignment operations and scoring systems\nCleaning single indel noise from pairwise codon alignment","category":"page"},{"location":"","page":"Home","title":"Home","text":"This documentation provides a deeper look into the package’s functionality, design, and customization options.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you're looking for installation, check out the README on GitHub.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#When-to-Use-SeededAlignment.jl","page":"Home","title":"When to Use SeededAlignment.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is ideal for:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Aligning coding DNA sequences where preserving the reading frame is critical\nPerforming fast pairwise alignments using seed-and-extend strategies\nCreating codon-aware multiple sequence alignments with a trusted reference\nCustomizing alignment scoring to handle mismatches, gaps, or biological constraints","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Core-Features","page":"Home","title":"Core Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"🔗 Seeded Pairwise Alignment — Fast alignment using k-mer seeding and chaining  \n🧬 Codon-Aware MSA — Align multiple sequences while preserving codon structure  \n⚙️ Custom Move Sets — Define allowed alignment operations (e.g., frameshifts, gaps)  \n🧠 Flexible Scoring — Easily adjust match/mismatch/gap penalties\n🧹 clean reading frame - Remove indels which break reading frame for a pairwise alignment  \n📄 FASTA Support — Simple reading and writing of sequence data  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Usage-Example","page":"Home","title":"Usage Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here's a full example using standard codon-aware alignment tools:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using SeededAlignment\nusing BioSequences\n\n# Create a reference and target sequences\nref = LongDNA{4}(\"ATGACGTGA\")  # Reference sequence\nseqs = [LongDNA{4}(\"ATGTCGTGA\"), LongDNA{4}(\"ATGACGAGA\")]\n\n# Use built-in codon_alignment parameter settings\nmoveset = std_codon_moveset()\nscoring = std_codon_scoring()\n\n# Align sequences to the reference\nalignment = msa_codon_align(ref, seqs, moveset, scoring)\n\n# Save result to FASTA\nwrite_fasta(\"alignment.fasta\", alignment)","category":"page"},{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"This page describes the core types that are used in the Package. These types are used for repesent dna sequences, alignment movement options and scoring of alignments. For reference the core type are presented below ","category":"page"},{"location":"types/#Core-Types","page":"Types","title":"Core Types","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"Move - represents an allowed alignment move during alignment (e.g. insert gap, or match nucleotide)\nMoveSet - represents a collection of Move objects\nScoreScheme - represents how different aspects of an alignment is scored (e.g. substitution penalty, extension penalty)\nLongDNA{4} - represents the dna sequences. See LongDNA in the BioSequences.jl documentation.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"In this document we outline in-depth how the Move, MoveSet and ScoreScheme types work. For documentation on LongDNA{4} we recommend looking at the documentation from [BioSequences.jl]. ","category":"page"},{"location":"types/#Move","page":"Types","title":"Move","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"Represents a single allowed move during alignment (e.g., a match, insertion, or deletion). Moves can preserve codon reading frames by aligning phases.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"Move(\n    step::Int, \n    score::Float64,         \n    horizontal_stride::Int, \n    horizontal_phase::Int,  \n    vertical_stride::Int,   \n    vertical_phase::Int,\n    extensionAble::Bool\n)","category":"page"},{"location":"types/#Fields","page":"Types","title":"Fields","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"step::Int: How many alignment matrix steps this move advances. E.g. a move could correspond to a gap of length 1 or a gap of lenth 3. \nscore::Float64: The cost (or negative score) for using this move once in an alignment. If a Move has a high score it will be used less in the optimal alignment. \nhorizontal_stride::Int: Bases consumed from the reference sequence.\nhorizontal_phase::Int: Frame offset in the reference (top sequence).\nvertical_stride::Int: Bases consumed from the query sequence.\nvertical_phase::Int: Frame offset in the query (bottom sequence).\nextensionAble::Bool: Whether this move can be extended (e.g., in gap extension scoring).","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"The stride and phase fields are what enable us to make some moves Codon-preserving. ","category":"page"},{"location":"types/#Constructors","page":"Types","title":"Constructors","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"For convenience, there are a few constructors:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"# keyword constructor\nMove(; step::Int, score::Float64, stride::Int, phase::Int, extensionAble::Bool=false)\n# \nMove(step, score, stride, phase, extensionAble=false)\n# ignore stide and phase considerations by letting stride = 1, phase = 0\nMove(step, score, extensionAble=false)","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"","category":"page"},{"location":"types/#MoveSet","page":"Types","title":"MoveSet","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"A MoveSet groups together the allowable match, insertion, and deletion moves used in dynamic programming.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"MoveSet(\n    match_moves::Vector{Move},\n    hor_moves::Vector{Move},\n    vert_moves::Vector{Move}\n)","category":"page"},{"location":"types/#Fields-2","page":"Types","title":"Fields","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"match_moves: Moves that align bases from both sequences (e.g., match/mismatch).\nhor_moves: Gaps in the reference sequence (insertions).\nvert_moves: Gaps in the query sequence (deletions).","category":"page"},{"location":"types/#Example","page":"Types","title":"Example","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"The default codon-aware move set is provided by:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"std_codon_moveset()","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"An example for a custom moveset is given by","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"match_moves = [Move(1,.0)]\nhor_moves =  [Move(1, 2.0, 1, 0, 1,0, false), Move(3, 2.0, 1,0,3,0, true)]\nvert_moves = [Move(1, 2.0, 1, 0, 1,0, false), Move(3, 2.0, 1,0,3,0, true)]\n\nmoveset = MoveSet(match_moves=match_moves, hor_moves=hor_moves, vert_moves = vert_moves)","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"","category":"page"},{"location":"types/#ScoreScheme","page":"Types","title":"ScoreScheme","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"Defines the scoring parameters used in alignment.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"ScoreScheme(\n    match_score::Float64,\n    mismatch_score::Float64,\n    extension_score::Float64,\n    edge_ext_begin::Bool,\n    edge_ext_end::Bool,\n    kmerlength::Int\n)\n# default values\nScoreScheme(; match_score=0.0, mismatch_score=0.5,extension_score=0.1,edge_ext_begin=true,edge_ext_end=true,kmerlength=21)","category":"page"},{"location":"types/#Fields-3","page":"Types","title":"Fields","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"match_score: Score for matching bases (typically 0).\nmismatch_score: Penalty for a mismatch.\nextension_score: Penalty for extending a gap.\nedge_ext_begin: Allow gap extension from the beginning of a sequence.\nedge_ext_end: Allow gap extension from the end of a sequence.\nkmerlength: Length of kmers used in alignment seeding (if applicable).","category":"page"},{"location":"types/#Examples","page":"Types","title":"Examples","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"Use the default scoring with:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"scoreScheme = std_codon_scoring()","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"For custom scoring we can se the keyword constructor. Fields that are left out are kept at their default values. ","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"scoreScheme = scoreScheme(match_score = 0.0, mismatch_score = 0.5, extension_score = 0.3)","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"","category":"page"},{"location":"types/#LongDNA{4}","page":"Types","title":"LongDNA{4}","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"See LongDNA in the BioSequences.jl documentation.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"","category":"page"},{"location":"types/#See-Also","page":"Types","title":"See Also","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"API Reference","category":"page"}]
}
