var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This section provides detailed documentation for all exported types and functions in SeededAlignment.jl.","category":"page"},{"location":"api/#Core-Methods","page":"API Reference","title":"Core Methods","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"seed_chain_align \nmsa_codon_align \nclean_frameshifts\nnw_align","category":"page"},{"location":"api/#Utilities","page":"API Reference","title":"Utilities","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"methods for reading and writing of sequence data in FASTA format.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"read_fasta\nwrite_fasta","category":"page"},{"location":"api/#Core-Types","page":"API Reference","title":"Core Types","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Move\nMoveset\nScoringScheme\nLongDNA{4}","category":"page"},{"location":"api/#Standard-Parameters","page":"API Reference","title":"Standard Parameters","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"std_scoring\nstd_codon_moveset\nstd_noisy_moveset","category":"page"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"A complete alphabetical listing of all documented functions.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/#Index-Docstrings","page":"API Reference","title":"Index Docstrings","text":"","category":"section"},{"location":"api/#SeededAlignment.Move","page":"API Reference","title":"SeededAlignment.Move","text":"Move\n\nRepresents a single allowed alignment step between two sequences in the alignment matrix.\n\nFields\n\nstep::Int: How many aligned units (nucleotides) this move advances by.\nscore::Float64: Cost or score associated with performing this move.\n\nReference to the top sequence (horizontal axis)\n\nhorizontal_stride::Int: How far this move advances along the top (reference) sequence.\nhorizontal_phase::Int: Frame offset in the top sequence; helps track codon boundaries.\n\nReference to the bottom sequence (vertical axis)\n\nvertical_stride::Int: How far this move advances along the bottom (query) sequence.\nvertical_phase::Int: Frame offset in the bottom sequence.\nextensionAble::Bool: Whether this move can be extended (e.g., for affine gap penalties).\n\nDescription\n\nMoves define basic operations used in dynamic programming alignment: matches, mismatches, and gaps. Moves can preserve codon reading frames by keeping strides in multiples of 3 and matching phase positions.\n\nTwo helper constructors are provided:\n\nMove(step, score, stride, phase, extensionAble) assumes reference (vertical) stride and phase\nMove(step, score, extensionAble) for simple moves with unit stride and zero phase.\n\n\n\n\n\n","category":"type"},{"location":"api/#SeededAlignment.ScoringScheme","page":"API Reference","title":"SeededAlignment.ScoringScheme","text":"ScoringScheme(; match_score=0.0, mismatch_score=0.5,extension_score=0.1,edge_ext_begin=true,edge_ext_end=true,kmerlength=21)\n\nA struct for storing scoring parameters used for sequence alignment. Uses a keyword constructor. \n\nFields\n\nmatch_score::Float64: Score (typically â‰¤ 0) awarded for matching nucleotide. Lower is better.\nmismatch_score::Float64: Penalty for nucleotide mismatches. Higher values penalize substitutions more strongly.\nextension_score::Float64: Cost to extend a gap (indel). Affects how gaps are penalized during alignment.\nedge_ext_begin::Bool: If true, allows gaps to be extended at the beginning of sequences.\nedge_ext_end::Bool: If true, allows gaps to be extended at the end of sequences.\nkmerlength::Int64: Length of k-mers used for seeding alignments (if applicable). Ignored if no seeding is used.\n\nDescription\n\nScoringScheme defines how matches, mismatches, and gaps are scored during nucleotide-level sequence alignment. \n\nThis struct is typically passed to functions like seed_chain_align or msa_codon_align.\n\nexample\n\nscore_params = ScoringScheme(extension_score = 0.3, mismatch_score = 0.7) # (everything else will be keept at default values)\n\n\n\n\n\n","category":"type"},{"location":"api/#SeededAlignment.clean_frameshifts-Tuple{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}","page":"API Reference","title":"SeededAlignment.clean_frameshifts","text":"clean_frameshifts(aligned_ref::LongDNA{4},aligned_seq::LongDNA{4}; verbose::Bool=false)\n\nTakes a pairwise alignment of a reference (with known reading frame) and a sequence, and removes frameshift mutations  which don't respect the reference's reading frame. This is done by removing insertions from the alignment or inserting  ambigious nucleotides into deletions.\n\nExamples:\n\ninsertion\n\nref: ATG-AACGTA  -> cleanedref: ATGAACGTA  seq: ATGTAACGTA  -> cleanedseq: ATGAACGTA\n\ndeletion\n\nref: ATGAACGTA  -> cleanedref: ATGAACGTA seq: ATG-ACGTA  -> cleanedseq: ATGNACGTA\n\nNOTE We always assume the readingFrame is 1\n\n\n\n\n\n","category":"method"},{"location":"api/#SeededAlignment.msa_codon_align-Tuple{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, Vector{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}}","page":"API Reference","title":"SeededAlignment.msa_codon_align","text":"msa_codon_align(ref::LongDNA{4}, seqs::Vector{LongDNA{4}}; moveset::Moveset=std_codon_moveset(), scoring::ScoringScheme=std_scoring(), match_codons=true::Bool, use_seeded=true::Bool)\n\nProduces a fast codon aligment with consistent readingFrame. \n\nArguments\n\nref::LongDNA{4}: The reference DNA sequence, assumed to have an readingFrame which starts at its first nucleotide.\nseqs::Vector{LongDNA{4}}: A vector of DNA sequences to align against the reference.\nmoveset::Moveset: Defines the allowable alignment operations (e.g. match nucleotide, single indel, readingFrame respecting triple indel). Assumes moveset is choosen so some moves respect the readingFrame.\nscore_params::ScoringScheme: Scoring parameters for codon-aware alignment, including match/mismatch and gap penalties.\n\nReturns\n\nVector{LongDNA{4}}: A vector of aligned sequences (including the reference), with codon-aware gaps that preserve reading frame consistency.\n\nDescription\n\nProduces a fast multiple codon alignment based on a reference with known readingFrame, a moveset and a ScoringScheme.  This is done by computing a pairwise alignment with respect to the reference for each sequence and then cleaning up single indel noise.\n\nExample\n\nref = LongDNA{4}(\"ATGACGTGA\")  # Reference with known reading frame\nseqs = [LongDNA{4}(\"ATGTCGTGA\"), LongDNA{4}(\"ATGACGAGA\")]\nmoveset = std_codon_moveset()\nscore_params = std_scoring()\n\nalignment = msa_codon_align(ref, seqs, moveset, score_params)\n\nNOTE: The sequences (ungapped) might not be preserved by the alignment by the cleanup step. Some nucleotides might be inserted or removed.  \n\n\n\n\n\n","category":"method"},{"location":"api/#SeededAlignment.nw_align-Tuple{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}","page":"API Reference","title":"SeededAlignment.nw_align","text":"nw_align(A::LongDNA{4},B::LongDNA{4}; moveset::Moveset=std_noisy_moveset(), scoring::ScoringScheme=std_scoring()\n\nNeedleman_Wunsch wrapper - no reference, i.e. makes no assumptions about the two sequences. \n\nComputes an optimal global pairwise alignment of two ungapped LongDNA{4} sequence   with respect to the Moveset and the ScoringScheme. \n\n\n\n\n\n","category":"method"},{"location":"api/#SeededAlignment.nw_align-Tuple{}","page":"API Reference","title":"SeededAlignment.nw_align","text":"nw_align(; ref::LongDNA{4}, query::LongDNA{4}, moveset::Moveset=std_codon_moveset(), scoring::ScoringScheme=std_scoring(),\n    do_clean_frameshifts=false::Bool, verbose=false::Bool, match_codons=true::Bool)\n\nNeedleman_Wunsch wrapper - reference informed, i.e. assumes one of the sequence has intact reading frame. \n\nOptimally aligns a query sequence to a ref sequence using a codon-aware Moveset and ScoringScheme. In particular ...  ... \n\nNOTE We always assume the readingFrame is 1\n\n\n\n\n\n","category":"method"},{"location":"api/#SeededAlignment.read_fasta-Tuple{String}","page":"API Reference","title":"SeededAlignment.read_fasta","text":"read_fasta(filepath::String)\n\nReads in a fasta file and returns a tuple of (seqnames, seqs).\n\n\n\n\n\n","category":"method"},{"location":"api/#SeededAlignment.seed_chain_align-Tuple{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}","page":"API Reference","title":"SeededAlignment.seed_chain_align","text":"seed_chain_align(A::LongDNA{4}, B::LongDNA{4}, moveset::Moveset, ScoringScheme::ScoringScheme)\n\nPerform pairwise alignment between two DNA sequences using a seeding strategy.\n\nArguments\n\nA::LongDNA{4}: The first DNA sequence to align.\nB::LongDNA{4}: The second DNA sequence to align.\nmoveset::Moveset: Defines allowed alignment moves (e.g., match, mismatch, gap).\nScoringScheme::ScoringScheme: Scoring scheme for e.g. matches, mismatches, and gaps.\n\nReturns\n\nVector{LongDNA{4}}: A vector the two aligned sequences.\n\nDescription\n\nThis function performs a fast (sub-quadratic) pairwise alignment using seeding and chaining. It identifies high-scoring seed matches between A and B, chains them to build a candidate alignment skeleton, and fills gaps between seeds using dynamic programming guided by moveset and ScoringScheme.\n\nExample\n\nA = LongDNA{4}(\"ACGTACGT\")\nB = LongDNA{4}(\"ACGTTGCA\")\nmoveset = std_codon_moveset()\nScoringScheme = std_scoring()\n\nalignment = seed_chain_align(A, B, moveset, ScoringScheme)\n\nseedchainalign wrapper - default noisy i.e no reference sequence\n\n\n\n\n\n","category":"method"},{"location":"api/#SeededAlignment.std_codon_moveset-Tuple{}","page":"API Reference","title":"SeededAlignment.std_codon_moveset","text":"std_codon_moveset()\n\nReturn a standard codon-aware Moveset for sequence alignment.\n\nReturns\n\nMoveset: Contains codon-aware match and gap moves.\n\nMoves\n\nMatch: Move(1, 0.0)\nHorizontal (gaps in reference sequence):\nMove(1, 2.0, 1, 0, 1, 0, false)\nMove(3, 2.0, 1, 0, 3, 0, true)\nVertical (gaps in query sequence):\nMove(1, 2.0, 1, 0, 1, 0, false)\nMove(3, 2.0, 1, 0, 3, 0, true)\n\nUse this as a default Moveset for codon-preserving alignments.\n\n\n\n\n\n","category":"method"},{"location":"api/#SeededAlignment.std_noisy_moveset-Tuple{}","page":"API Reference","title":"SeededAlignment.std_noisy_moveset","text":"pairwise_noisy_moveset()\n\n\n\n\n\n","category":"method"},{"location":"api/#SeededAlignment.std_scoring-Tuple{}","page":"API Reference","title":"SeededAlignment.std_scoring","text":"std_codon_scoring()\n\nReturn a standard codon-aware ScoringScheme for alignment.\n\nReturns\n\nScoringScheme: Default scoring parameters for codon alignment.\n\nParameters\n\nMatch score: 0.0\nMismatch score: 0.3\nGap extension score: 0.1\nAllow extension at sequence ends: true (both ends)\nK-mer length for seeding: 18\n\nUse this as a default ScoringScheme for codon-preserving alignments.\n\n\n\n\n\n","category":"method"},{"location":"api/#SeededAlignment.write_fasta-Tuple{String, Tuple{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}}","page":"API Reference","title":"SeededAlignment.write_fasta","text":"write_fasta(filepath::String, sequences::Tuple{LongDNA{4},LongDNA{4}}; seq_names = nothing)\n\nWrites a fasta file from a Tuple of sequences, with optional seq_names.\n\n\n\n\n\n","category":"method"},{"location":"api/#SeededAlignment.write_fasta-Tuple{String, Vector{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}}","page":"API Reference","title":"SeededAlignment.write_fasta","text":"write_fasta(filepath::String, sequences::Vector{LongDNA{4}}; seq_names = nothing)\n\nWrites a fasta file from a vector of sequences, with optional seq_names.\n\n\n\n\n\n","category":"method"},{"location":"customizing_alignments/#Customizing-Alignments","page":"Customizing Alignments","title":"Customizing Alignments","text":"","category":"section"},{"location":"customizing_alignments/","page":"Customizing Alignments","title":"Customizing Alignments","text":"Coming Soon!","category":"page"},{"location":"#SeededAlignment.jl","page":"Home","title":"SeededAlignment.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SeededAlignment.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This documentation is a complement to the README on GitHub which explains the purpose, installation, core methods, use cases, and examples in detail. These pages are mainly intended for users who want to consult to the API Reference, or advanced users who want to learn how to define their own alignment operations and scoring.  ","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Getting Started (README)    Installation, basic usage, and overview of the package's goals.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Customizing Alignments    How to define custom scoring schemes, alignment operations, and seed constraints.","category":"page"},{"location":"","page":"Home","title":"Home","text":"API Reference    Full list of exported types and functions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For issues, feature requests, or contributions, see the GitHub repository.","category":"page"}]
}
