var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = SeededAlignment","category":"page"},{"location":"#SeededAlignment","page":"Home","title":"SeededAlignment","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SeededAlignment.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SeededAlignment]","category":"page"},{"location":"#SeededAlignment.Move","page":"Home","title":"SeededAlignment.Move","text":"Move\n\nRepresents a single allowed alignment step between two sequences in the alignment matrix.\n\nFields\n\nstep::Int: How many aligned units (nucleotides) this move advances by.\nscore::Float64: Cost or score associated with performing this move.\n\nReference to the top sequence (horizontal axis)\n\nhorizontal_stride::Int: How far this move advances along the top (reference) sequence.\nhorizontal_phase::Int: Frame offset in the top sequence; helps track codon boundaries.\n\nReference to the bottom sequence (vertical axis)\n\nvertical_stride::Int: How far this move advances along the bottom (query) sequence.\nvertical_phase::Int: Frame offset in the bottom sequence.\nextensionAble::Bool: Whether this move can be extended (e.g., for affine gap penalties).\n\nDescription\n\nMoves define basic operations used in dynamic programming alignment: matches, mismatches, and gaps. Moves can preserve codon reading frames by keeping strides in multiples of 3 and matching phase positions.\n\nTwo helper constructors are provided:\n\nMove(step, score, stride, phase, extensionAble) assumes reference (vertical) stride and phase\nMove(step, score, extensionAble) for simple moves with unit stride and zero phase.\n\n\n\n\n\n","category":"type"},{"location":"#SeededAlignment.MoveSet","page":"Home","title":"SeededAlignment.MoveSet","text":"MoveSet\n\nDefines the full set of allowed alignment moves used during pairwise or multiple sequence alignment.\n\nFields\n\nmatch_moves::Vector{Move}: Moves that represent matches or substitutions between nucleotides. \nhor_moves::Vector{Move}: Moves that introduce gaps in the reference (horizontal) sequence.\nvert_moves::Vector{Move}: Moves that introduce gaps in the query (vertical) sequence.\n\nDescription\n\nA MoveSet groups the allowable Moves into categories used during dynamic programming alignment. Each type controls how the algorithm can transition between states, including nucleotide-level match and gap moves with customizable reading frame behavior.\n\nUsed by alignment algorithms such as seed_chain_align and  msa_codon_align to control the scoring and allowed operations during alignment.\n\n\n\n\n\n","category":"type"},{"location":"#SeededAlignment.ScoreScheme","page":"Home","title":"SeededAlignment.ScoreScheme","text":"ScoreScheme\n\nScoring parameters used for codon-aware sequence alignment.\n\nFields\n\nmatch_score::Float64: Score (typically â‰¤ 0) awarded for matching codons. Lower is better.\nmismatch_score::Float64: Penalty for codon mismatches. Higher values penalize substitutions more strongly.\nextension_score::Float64: Cost to extend a gap (indel). Affects how gaps are penalized during alignment.\nedge_ext_begin::Bool: If true, allows gaps to be extended at the beginning of sequences.\nedge_ext_end::Bool: If true, allows gaps to be extended at the end of sequences.\nkmerlength::Int64: Length of k-mers used for seeding alignments (if applicable). Ignored if no seeding is used.\n\nDescription\n\nScoreScheme defines how matches, mismatches, and gaps are scored during codon-level sequence alignment. It also controls whether edge gaps can be extended and optionally includes a kmerlength for seed-based aligners.\n\nThis struct is typically passed to functions like seed_chain_align or msa_codon_align.\n\n\n\n\n\n","category":"type"},{"location":"#SeededAlignment.clean_alignment_readingframe-Tuple{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}","page":"Home","title":"SeededAlignment.clean_alignment_readingframe","text":"clean_alignment_readingframe(aligned_ref::LongDNA{4},aligned_seq::LongDNA{4})\n\nTakes a pairwise alignment of a reference (with known reading frame) and a sequence, and removes single indels which\ndon't respect the reference's reading frame. To clean a full codon alignment you need multiple pairwise alignments and can clean up \nsingle indels by broadcasting with \".\" \n\n# NOTE We assume the readingFrame is 0 mod 3 with sequences 0 indexed\n\n\n\n\n\n","category":"method"},{"location":"#SeededAlignment.msa_codon_align-Tuple{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, Vector{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}, MoveSet, ScoreScheme}","page":"Home","title":"SeededAlignment.msa_codon_align","text":"msa_codon_align(ref::LongDNA{4}, seqs::Vector{LongDNA{4}}, moveset::MoveSet, score_params::ScoreScheme)\n\nProduces a fast codon aligment with consistent readingFrame. \n\nArguments\n\nref::LongDNA{4}: The reference DNA sequence, assumed to have an readingFrame which starts at its first nucleotide.\nseqs::Vector{LongDNA{4}}: A vector of DNA sequences to align against the reference.\nmoveset::MoveSet: Defines the allowable alignment operations (e.g. match nucleotide, single indel, readingFrame respecting triple indel). Assumes moveset is choosen so some moves respect the readingFrame.\nscore_params::ScoreScheme: Scoring parameters for codon-aware alignment, including match/mismatch and gap penalties.\n\nReturns\n\nVector{LongDNA{4}}: A vector of aligned sequences (including the reference), with codon-aware gaps that preserve reading frame consistency.\n\nDescription\n\nProduces a fast multiple codon alignment based on a reference with known readingFrame, a moveset and a scoreScheme.  This is done by computing a pairwise alignment with respect to the reference for each sequence and then cleaning up single indel noise.\n\nExample\n\nref = LongDNA{4}(\"ATGACGTGA\")  # Reference with known reading frame\nseqs = [LongDNA{4}(\"ATGTCGTGA\"), LongDNA{4}(\"ATGACGAGA\")]\nmoveset = std_codon_moveset()\nscore_params = std_codon_scoring()\n\nalignment = msa_codon_align(ref, seqs, moveset, score_params)\n\nNOTE: The sequences (ungapped) might not be preserved by the alignment by the cleanup step. Some nucleotides might be inserted or removed.  \n\n\n\n\n\n","category":"method"},{"location":"#SeededAlignment.nw_align-Tuple{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, MoveSet, ScoreScheme}","page":"Home","title":"SeededAlignment.nw_align","text":"nw_align(A::LongDNA{4},B::LongDNA{4},moveset::MoveSet,scoreScheme::ScoreScheme)\n\nTakes two ungapped LongDNA{4} sequences and computes an optimal pairwise alignment \nwith respect to the moveset and the scoreScheme.\n\n\n\n\n\n","category":"method"},{"location":"#SeededAlignment.pairwise_noisy_moveset-Tuple{}","page":"Home","title":"SeededAlignment.pairwise_noisy_moveset","text":"pairwise_noisy_moveset()\n\n\n\n\n\n","category":"method"},{"location":"#SeededAlignment.read_fasta-Tuple{String}","page":"Home","title":"SeededAlignment.read_fasta","text":"read_fasta(filepath::String)\n\nReads in a fasta file and returns a tuple of (seqnames, seqs).\n\n\n\n\n\n","category":"method"},{"location":"#SeededAlignment.seed_chain_align-Tuple{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, MoveSet, ScoreScheme}","page":"Home","title":"SeededAlignment.seed_chain_align","text":"seed_chain_align(A::LongDNA{4}, B::LongDNA{4}, moveset::MoveSet, scoreScheme::ScoreScheme)\n\nPerform pairwise alignment between two DNA sequences using a seeding strategy.\n\nArguments\n\nA::LongDNA{4}: The first DNA sequence to align.\nB::LongDNA{4}: The second DNA sequence to align.\nmoveset::MoveSet: Defines allowed alignment moves (e.g., match, mismatch, gap).\nscoreScheme::ScoreScheme: Scoring scheme for e.g. matches, mismatches, and gaps.\n\nReturns\n\nVector{LongDNA{4}}: A vector the two aligned sequences.\n\nDescription\n\nThis function performs a fast (sub-quadratic) pairwise alignment using seeding and chaining. It identifies high-scoring seed matches between A and B, chains them to build a candidate alignment skeleton, and fills gaps between seeds using dynamic programming guided by moveset and scoreScheme.\n\nExample\n\nA = LongDNA{4}(\"ACGTACGT\")\nB = LongDNA{4}(\"ACGTTGCA\")\nmoveset = std_codon_moveset()\nscoreScheme = std_codon_scoring()\n\nalignment = seed_chain_align(A, B, moveset, scoreScheme)\n\n\n\n\n\n","category":"method"},{"location":"#SeededAlignment.std_codon_scoring-Tuple{}","page":"Home","title":"SeededAlignment.std_codon_scoring","text":"std_codon_scoring()\n\nReturn a standard codon-aware ScoreScheme for alignment.\n\nReturns\n\nScoreScheme: Default scoring parameters for codon alignment.\n\nParameters\n\nMatch score: 0.0\nMismatch score: 0.3\nGap extension score: 0.1\nAllow extension at sequence ends: true (both ends)\nK-mer length for seeding: 21\n\nUse this as a default ScoreScheme for codon-preserving alignments.\n\n\n\n\n\n","category":"method"},{"location":"#SeededAlignment.write_fasta-Tuple{String, Vector{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}}","page":"Home","title":"SeededAlignment.write_fasta","text":"write_fasta(filepath::String, sequences::Vector{LongDNA{4}}; seq_names = nothing)\n\nWrites a fasta file from a vector of sequences, with optional seq_names.\n\n\n\n\n\n","category":"method"}]
}
